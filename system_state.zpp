/*******************************************************************************
 * WhatsApp Clone - System State Formal Specification (Z++)
 * 
 * This specification formalizes the overall system state of the WhatsApp Clone
 * backend, including runtime state, session management, authentication context,
 * and caching layers.
 * 
 * Builds upon data_model.zpp to define the complete runtime system state.
 ******************************************************************************/

include "data_model.zpp"


/*******************************************************************************
 * SECTION 1: SESSION AND AUTHENTICATION STATE
 ******************************************************************************/

/*
 * JSON Web Token (JWT)
 * 
 * Represents an encoded authentication token containing the username.
 * Format: Base64-encoded JSON signed with HMAC-SHA256.
 */
AuthToken == seq char

/*
 * JWT Secret Key
 * 
 * Secret key used to sign and verify JWT tokens.
 * Loaded from environment variable or defaults to 'secret-value'.
 */
JWTSecret == seq char

/*
 * Token Expiration
 * 
 * Time-to-live for JWT tokens in milliseconds.
 * Default: 365 days
 */
TokenExpiration == â„•

given
  DEFAULT_EXPIRATION == 365 * 24 * 60 * 60 * 1000  // milliseconds


/*
 * Authentication Cookie
 * 
 * HTTP cookie containing the authentication token.
 * Set as HTTP-only for security.
 */
schema AuthCookie
  name: seq char
  value: AuthToken
  maxAge: TokenExpiration
  httpOnly: ð”¹
where
  name = "authToken" âˆ§
  httpOnly = true âˆ§
  maxAge > 0


/*
 * HTTP Request Context
 * 
 * Represents the HTTP request context containing cookies and headers.
 */
schema HTTPRequest
  cookies: seq char â‡¸ seq char
  headers: seq char â‡¸ seq char
  method: seq char
  path: seq char
where
  method âˆˆ {"GET", "POST", "PUT", "DELETE", "OPTIONS"}


/*
 * HTTP Response Context
 * 
 * Represents the HTTP response context for setting cookies and headers.
 */
schema HTTPResponse
  cookies: seq AuthCookie
  headers: seq char â‡¸ seq char
  statusCode: â„•
where
  statusCode â‰¥ 100 âˆ§ statusCode < 600


/*
 * Session State
 * 
 * Represents a single user session tied to a GraphQL request.
 * Session-scoped providers (Auth, Chats) are instantiated per session.
 * 
 * Maps to: ModuleSessionInfo in @graphql-modules/core
 */
schema SessionState
  sessionId: seq char
  request: HTTPRequest
  response: HTTPResponse
  currentUser: UserID âˆª {null}
  startTime: DateTime
where
  /* Session must have unique ID */
  #sessionId > 0


/*
 * Active Sessions
 * 
 * Collection of all active sessions in the system.
 */
schema ActiveSessions
  sessions: seq char â‡¸ SessionState
where
  /* Each session ID maps to its session state */
  âˆ€ sid: seq char â€¢ sid âˆˆ dom sessions â‡’ sessions(sid).sessionId = sid


/*******************************************************************************
 * SECTION 2: AUTHENTICATION STATE
 ******************************************************************************/

/*
 * JWT Claims
 * 
 * Data encoded in a JWT token.
 * For this system, JWT contains only the username.
 */
schema JWTClaims
  username: Username
  issuedAt: DateTime
  expiresAt: DateTime
where
  issuedAt < expiresAt


/*
 * Authentication Configuration
 * 
 * System-wide authentication configuration.
 * Maps to: env.ts (secret, expiration)
 */
schema AuthConfig
  jwtSecret: JWTSecret
  tokenExpiration: TokenExpiration
where
  #jwtSecret > 0 âˆ§
  tokenExpiration > 0


/*
 * Authentication Context
 * 
 * Runtime authentication state for the current session.
 * 
 * Maps to: Auth provider in modules/users/auth.provider.ts
 */
schema AuthContext
  SessionState
  Users
  authConfig: AuthConfig
  authenticated: ð”¹
where
  /* If authenticated, currentUser must be valid */
  authenticated = true â‡’ currentUser âˆˆ dom users âˆ§ currentUser â‰  null
  âˆ§
  /* If not authenticated, currentUser must be null */
  authenticated = false â‡’ currentUser = null


/*
 * Helper function: Verify JWT Token
 * 
 * Verifies a JWT token and extracts the username.
 * Returns null if token is invalid or expired.
 */
verifyJWT: AuthToken Ã— JWTSecret Ã— DateTime â†’ (Username âˆª {null})
âˆ€ token: AuthToken; secret: JWTSecret; currentTime: DateTime â€¢
  /* Abstract specification - actual implementation uses jsonwebtoken library */
  true


/*
 * Helper function: Sign JWT Token
 * 
 * Creates a JWT token for a username.
 */
signJWT: Username Ã— JWTSecret â†’ AuthToken
âˆ€ username: Username; secret: JWTSecret â€¢
  /* Abstract specification - actual implementation uses jsonwebtoken library */
  true


/*******************************************************************************
 * SECTION 3: CACHING STATE
 ******************************************************************************/

/*
 * DataLoader Cache Entry
 * 
 * Represents a cached value in DataLoader with timestamp.
 */
[CacheKey]  // Abstract cache key type

schema CacheEntry[T]
  key: CacheKey
  value: T
  timestamp: DateTime
where
  timestamp > 0


/*
 * DataLoader State
 * 
 * Request-scoped cache for batching and caching database queries.
 * 
 * Maps to: DataLoader instances in ChatsProvider
 */
schema DataLoaderState
  chatCache: CacheKey â‡¸ Chat
  messageCache: CacheKey â‡¸ Message
  userCache: CacheKey â‡¸ User
  batchQueue: seq (CacheKey Ã— DateTime)
where
  /* Cache is cleared at end of request */
  /* Batch queue processes pending loads */
  true


/*******************************************************************************
 * SECTION 4: PUBSUB STATE (Real-time Subscriptions)
 ******************************************************************************/

/*
 * PubSub Event Types
 */
EventType ::= messageAdded | chatAdded | chatRemoved

/*
 * PubSub Event
 * 
 * Represents an event published to subscribers.
 */
schema PubSubEvent
  eventType: EventType
  payload: MessageID âˆª ChatID  // Depends on event type
  timestamp: DateTime
where
  timestamp > 0


/*
 * Subscription Filter
 * 
 * Function to determine if a subscriber should receive an event.
 * Used in withFilter for GraphQL subscriptions.
 */
SubscriptionFilter == PubSubEvent Ã— SessionState â†’ ð”¹


/*
 * Active Subscription
 * 
 * Represents an active GraphQL subscription from a client.
 */
schema ActiveSubscription
  subscriptionId: seq char
  sessionId: seq char
  eventType: EventType
  filter: SubscriptionFilter
  createdAt: DateTime
where
  #subscriptionId > 0 âˆ§
  #sessionId > 0


/*
 * PubSub State
 * 
 * Manages real-time event publishing and subscription.
 * 
 * Maps to: PubSub provider using graphql-postgres-subscriptions
 */
schema PubSubState
  subscriptions: seq char â‡¸ ActiveSubscription
  eventQueue: seq PubSubEvent
  postgresChannel: seq char â‡¸ EventType
where
  /* Each subscription ID maps to an active subscription */
  âˆ€ sid: seq char â€¢ sid âˆˆ dom subscriptions â‡’ 
    subscriptions(sid).subscriptionId = sid
  âˆ§
  /* PostgreSQL LISTEN channels map to event types */
  âˆ€ channel: seq char â€¢ channel âˆˆ dom postgresChannel â‡’
    channel âˆˆ {"messageAdded", "chatAdded", "chatRemoved"}


/*******************************************************************************
 * SECTION 5: DATABASE CONNECTION POOL STATE
 ******************************************************************************/

/*
 * Database Connection
 * 
 * Represents a single connection to PostgreSQL.
 */
schema DBConnection
  connectionId: seq char
  inUse: ð”¹
  createdAt: DateTime
  lastUsed: DateTime
where
  #connectionId > 0 âˆ§
  lastUsed â‰¥ createdAt


/*
 * Connection Pool State
 * 
 * Manages a pool of database connections.
 * 
 * Maps to: pg.Pool in db.ts
 */
schema ConnectionPoolState
  connections: seq char â‡¸ DBConnection
  maxConnections: â„•
  idleTimeout: â„•
  connectionString: seq char
where
  /* Number of connections does not exceed max */
  #(dom connections) â‰¤ maxConnections âˆ§
  maxConnections > 0 âˆ§
  idleTimeout > 0


/*******************************************************************************
 * SECTION 6: EXTERNAL API STATE
 ******************************************************************************/

/*
 * Unsplash API Configuration
 * 
 * Configuration for Unsplash API integration.
 */
schema UnsplashConfig
  accessKey: seq char
  baseURL: URL
where
  #accessKey > 0 âˆ§
  baseURL = "https://api.unsplash.com"


/*
 * REST Data Source Cache
 * 
 * Apollo REST Data Source provides HTTP caching.
 * Maps to: UnsplashApi extends RESTDataSource
 */
schema RESTDataSourceCache
  urlCache: URL â‡¸ (seq char Ã— DateTime)  // (response, timestamp) pairs
  cacheTTL: â„•
where
  cacheTTL > 0


/*
 * External API State
 * 
 * State for external API integrations.
 */
schema ExternalAPIState
  unsplashConfig: UnsplashConfig
  unsplashCache: RESTDataSourceCache


/*******************************************************************************
 * SECTION 7: COMPLETE SYSTEM STATE
 ******************************************************************************/

/*
 * Runtime Configuration
 * 
 * System-wide runtime configuration loaded from environment.
 * Maps to: env.ts
 */
schema RuntimeConfig
  authConfig: AuthConfig
  databaseConfig: ConnectionPoolState
  serverPort: â„•
  serverOrigin: URL
  resetDbOnStartup: ð”¹
  fakedDbRecords: â„•
where
  serverPort > 0 âˆ§ serverPort < 65536


/*
 * Complete Application State
 * 
 * This schema represents the complete runtime state of the WhatsApp Clone
 * backend server at any point in time.
 */
schema ApplicationState
  /* Persistent Data Layer */
  DatabaseState
  
  /* Runtime State */
  activeSessions: ActiveSessions
  authContext: AuthConfig
  pubsubState: PubSubState
  connectionPool: ConnectionPoolState
  externalAPIs: ExternalAPIState
  config: RuntimeConfig
  
  /* Server Lifecycle */
  serverStartTime: DateTime
  serverRunning: ð”¹
where
  /* Server must have started if it's running */
  serverRunning = true â‡’ serverStartTime > 0
  âˆ§
  /* All active sessions reference valid users or are unauthenticated */
  âˆ€ sid: seq char â€¢ sid âˆˆ dom activeSessions.sessions â‡’
    let session == activeSessions.sessions(sid) â€¢
      session.currentUser â‰  null â‡’ session.currentUser âˆˆ dom users
  âˆ§
  /* All active subscriptions reference active sessions */
  âˆ€ subId: seq char â€¢ subId âˆˆ dom pubsubState.subscriptions â‡’
    pubsubState.subscriptions(subId).sessionId âˆˆ dom activeSessions.sessions


/*******************************************************************************
 * SECTION 8: SESSION LIFECYCLE SCHEMAS
 ******************************************************************************/

/*
 * Initial System State
 * 
 * System state when server starts.
 */
schema InitialApplicationState
  ApplicationState
where
  /* No active sessions initially */
  dom activeSessions.sessions = âˆ…
  âˆ§
  /* No active subscriptions initially */
  dom pubsubState.subscriptions = âˆ…
  âˆ§
  /* Server is running */
  serverRunning = true
  âˆ§
  /* Database is initialized (possibly with sample data) */
  config.resetDbOnStartup = true â‡’ 
    /* Sample database state conditions */
    #(dom users) â‰¥ 5 âˆ§ #(dom chats) â‰¥ 4


/*
 * Operation: Create Session
 * 
 * Creates a new session when a GraphQL request arrives.
 */
schema CreateSession
  Î”ApplicationState
  request?: HTTPRequest
  response?: HTTPResponse
  newSessionId!: seq char
where
  /* Generate unique session ID */
  newSessionId! âˆ‰ dom activeSessions.sessions
  âˆ§
  /* Create new session state */
  let newSession == SessionState' | 
    newSession.sessionId = newSessionId! âˆ§
    newSession.request = request? âˆ§
    newSession.response = response? âˆ§
    newSession.currentUser = null âˆ§
    newSession.startTime = /* current time */ â€¢
    activeSessions'.sessions = 
      activeSessions.sessions âŠ• {newSessionId! â†¦ newSession}
  âˆ§
  /* Rest of state unchanged */
  DatabaseState' = DatabaseState âˆ§
  pubsubState' = pubsubState âˆ§
  connectionPool' = connectionPool


/*
 * Operation: Destroy Session
 * 
 * Cleans up session when request completes.
 */
schema DestroySession
  Î”ApplicationState
  sessionId?: seq char
where
  sessionId? âˆˆ dom activeSessions.sessions
  âˆ§
  /* Remove session from active sessions */
  activeSessions'.sessions = activeSessions.sessions âŠ– {sessionId?}
  âˆ§
  /* Remove associated subscriptions */
  pubsubState'.subscriptions = 
    {sid â†¦ sub | sid: seq char; sub: ActiveSubscription â€¢
      sid âˆˆ dom pubsubState.subscriptions âˆ§
      sub = pubsubState.subscriptions(sid) âˆ§
      sub.sessionId â‰  sessionId?}
  âˆ§
  /* Rest of state unchanged */
  DatabaseState' = DatabaseState âˆ§
  connectionPool' = connectionPool


/*******************************************************************************
 * SECTION 9: SUBSCRIPTION LIFECYCLE SCHEMAS
 ******************************************************************************/

/*
 * Operation: Create Subscription
 * 
 * Creates a new GraphQL subscription.
 */
schema CreateSubscription
  Î”ApplicationState
  sessionId?: seq char
  eventType?: EventType
  filter?: SubscriptionFilter
  subscriptionId!: seq char
where
  /* Session must exist */
  sessionId? âˆˆ dom activeSessions.sessions
  âˆ§
  /* Generate unique subscription ID */
  subscriptionId! âˆ‰ dom pubsubState.subscriptions
  âˆ§
  /* Create new subscription */
  let newSub == ActiveSubscription' |
    newSub.subscriptionId = subscriptionId! âˆ§
    newSub.sessionId = sessionId? âˆ§
    newSub.eventType = eventType? âˆ§
    newSub.filter = filter? âˆ§
    newSub.createdAt = /* current time */ â€¢
    pubsubState'.subscriptions = 
      pubsubState.subscriptions âŠ• {subscriptionId! â†¦ newSub}
  âˆ§
  /* Rest of state unchanged */
  DatabaseState' = DatabaseState âˆ§
  activeSessions' = activeSessions


/*
 * Operation: Publish Event
 * 
 * Publishes an event to all matching subscribers.
 */
schema PublishEvent
  Î”ApplicationState
  event?: PubSubEvent
  notifiedSessions!: â„™(seq char)
where
  /* Add event to queue */
  pubsubState'.eventQueue = pubsubState.eventQueue âŒ¢ âŸ¨event?âŸ©
  âˆ§
  /* Determine which subscriptions should receive the event */
  notifiedSessions! = 
    {sub.sessionId | sub: ActiveSubscription â€¢
      sub âˆˆ ran pubsubState.subscriptions âˆ§
      sub.eventType = event?.eventType âˆ§
      sub.filter(event?, activeSessions.sessions(sub.sessionId))}
  âˆ§
  /* Send event to PostgreSQL NOTIFY */
  /* Implementation detail: PostgreSQL NOTIFY event?.eventType */
  true
  âˆ§
  /* Rest of state unchanged */
  DatabaseState' = DatabaseState âˆ§
  activeSessions' = activeSessions


/*******************************************************************************
 * SECTION 10: SYSTEM INVARIANTS
 ******************************************************************************/

/*
 * Global System Invariants
 * 
 * Properties that must hold for all valid system states.
 */
schema SystemInvariants
  ApplicationState
where
  /* Authenticated sessions reference valid users */
  âˆ€ sid: seq char â€¢ sid âˆˆ dom activeSessions.sessions â‡’
    let session == activeSessions.sessions(sid) â€¢
      session.currentUser â‰  null â‡’ session.currentUser âˆˆ dom users
  âˆ§
  /* Subscriptions only exist for active sessions */
  âˆ€ subId: seq char â€¢ subId âˆˆ dom pubsubState.subscriptions â‡’
    pubsubState.subscriptions(subId).sessionId âˆˆ dom activeSessions.sessions
  âˆ§
  /* Connection pool does not exceed maximum */
  #(dom connectionPool.connections) â‰¤ connectionPool.maxConnections
  âˆ§
  /* All database integrity constraints are maintained */
  /* (inherited from DatabaseIntegrity in data_model.zpp) */
  true


/*******************************************************************************
 * SECTION 11: HEALTH AND MONITORING STATE
 ******************************************************************************/

/*
 * System Health Metrics
 * 
 * Runtime metrics for monitoring system health.
 */
schema SystemMetrics
  activeSessionCount: â„•
  activeSubscriptionCount: â„•
  activeConnectionCount: â„•
  totalUsers: â„•
  totalChats: â„•
  totalMessages: â„•
  uptime: â„•
where
  activeSessionCount â‰¥ 0 âˆ§
  activeSubscriptionCount â‰¥ 0 âˆ§
  activeConnectionCount â‰¥ 0 âˆ§
  totalUsers â‰¥ 0 âˆ§
  totalChats â‰¥ 0 âˆ§
  totalMessages â‰¥ 0 âˆ§
  uptime â‰¥ 0


/*
 * Operation: Get System Metrics
 * 
 * Retrieves current system metrics.
 */
schema GetSystemMetrics
  ÎžApplicationState
  metrics!: SystemMetrics
where
  metrics!.activeSessionCount = #(dom activeSessions.sessions) âˆ§
  metrics!.activeSubscriptionCount = #(dom pubsubState.subscriptions) âˆ§
  metrics!.activeConnectionCount = 
    #{cid: seq char | cid âˆˆ dom connectionPool.connections âˆ§ 
      connectionPool.connections(cid).inUse = true} âˆ§
  metrics!.totalUsers = #(dom users) âˆ§
  metrics!.totalChats = #(dom chats) âˆ§
  metrics!.totalMessages = #(dom messages) âˆ§
  metrics!.uptime = /* current time */ - serverStartTime


/*******************************************************************************
 * END OF SYSTEM STATE SPECIFICATION
 ******************************************************************************/

/*
 * NOTES ON IMPLEMENTATION:
 * 
 * 1. Session Management:
 *    - Sessions created per GraphQL request via GraphQL Modules
 *    - Session-scoped providers instantiated per request
 *    - Session cleaned up after request completes
 * 
 * 2. DataLoader Caching:
 *    - Request-scoped cache, cleared after request
 *    - Batches database queries within single event loop tick
 *    - Prevents N+1 query problem
 * 
 * 3. PubSub Implementation:
 *    - Uses PostgreSQL LISTEN/NOTIFY for scalability
 *    - Events filtered per subscriber using withFilter
 *    - Subscription lifecycle tied to WebSocket connection
 * 
 * 4. Connection Pooling:
 *    - pg.Pool manages connections
 *    - Connections reused across requests
 *    - Idle connections closed after timeout
 * 
 * 5. Authentication Token:
 *    - JWT stored in HTTP-only cookie
 *    - Token verified on each request
 *    - currentUser cached in session provider
 */

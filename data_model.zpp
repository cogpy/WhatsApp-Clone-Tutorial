/*******************************************************************************
 * WhatsApp Clone - Data Model Formal Specification (Z++)
 * 
 * This specification formalizes the data layer of the WhatsApp Clone backend,
 * including all database entities, their relationships, and data invariants.
 * 
 * Based on PostgreSQL schema defined in db.ts
 ******************************************************************************/

/*******************************************************************************
 * SECTION 1: BASE TYPES AND CONSTANTS
 ******************************************************************************/

/* Basic Types */
[UserID, ChatID, MessageID]  // Distinct identifier types

/* String Constraints */
given
  MIN_USERNAME_LENGTH == 3
  MAX_USERNAME_LENGTH == 18
  MIN_NAME_LENGTH == 3
  MAX_NAME_LENGTH == 50
  MIN_PASSWORD_LENGTH == 8
  MAX_MESSAGE_LENGTH == 355

/* Type Definitions for Constrained Strings */
Username == {s: seq char | MIN_USERNAME_LENGTH ‚â§ #s ‚àß #s ‚â§ MAX_USERNAME_LENGTH}
UserName == {s: seq char | MIN_NAME_LENGTH ‚â§ #s ‚àß #s ‚â§ MAX_NAME_LENGTH}
Password == {s: seq char | MIN_PASSWORD_LENGTH ‚â§ #s}
HashedPassword == seq char  // bcrypt hash format: $2a$08$...
MessageContent == {s: seq char | 1 ‚â§ #s ‚àß #s ‚â§ MAX_MESSAGE_LENGTH}
URL == seq char  // URL format for pictures
DateTime == ‚Ñï  // Unix timestamp in milliseconds


/*******************************************************************************
 * SECTION 2: CORE DATA ENTITIES
 ******************************************************************************/

/*
 * User Entity
 * 
 * Represents a user account in the system.
 * Maps to the 'users' table in PostgreSQL.
 * 
 * Database Schema:
 *   CREATE TABLE users(
 *     id SERIAL PRIMARY KEY,
 *     username VARCHAR (50) UNIQUE NOT NULL,
 *     name VARCHAR (50) NOT NULL,
 *     password VARCHAR (255) NOT NULL,  -- bcrypt hashed
 *     picture VARCHAR (255) NOT NULL
 *   );
 */
schema User
  id: UserID
  username: Username
  name: UserName
  password: HashedPassword
  picture: URL
where
  /* Username uniqueness enforced by database UNIQUE constraint */
  /* Password stored as bcrypt hash, never plaintext */
  /* Picture URL must be valid, either from Unsplash or randomuser.me */
  true


/*
 * Chat Entity
 * 
 * Represents a conversation between two or more users.
 * Maps to the 'chats' table in PostgreSQL.
 * 
 * Database Schema:
 *   CREATE TABLE chats(
 *     id SERIAL PRIMARY KEY
 *   );
 * 
 * Note: The chat entity is minimal in the database. Additional properties
 * like name and picture are derived from participants at query time.
 */
schema Chat
  id: ChatID
where
  true


/*
 * Message Entity
 * 
 * Represents a message sent in a chat by a user.
 * Maps to the 'messages' table in PostgreSQL.
 * 
 * Database Schema:
 *   CREATE TABLE messages(
 *     id SERIAL PRIMARY KEY,
 *     content VARCHAR (355) NOT NULL,
 *     created_at TIMESTAMP NOT NULL DEFAULT NOW(),
 *     chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,
 *     sender_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE
 *   );
 */
schema Message
  id: MessageID
  content: MessageContent
  created_at: DateTime
  chat_id: ChatID
  sender_user_id: UserID
where
  /* Content must not be empty */
  #content > 0
  ‚àß
  /* Timestamp must be valid (not in future, not before epoch) */
  created_at > 0


/*
 * ChatParticipant Relationship
 * 
 * Represents the many-to-many relationship between chats and users.
 * Maps to the 'chats_users' join table in PostgreSQL.
 * 
 * Database Schema:
 *   CREATE TABLE chats_users(
 *     chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,
 *     user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE
 *   );
 */
schema ChatParticipant
  chat_id: ChatID
  user_id: UserID
where
  /* Both foreign keys must be valid */
  true


/*******************************************************************************
 * SECTION 3: COLLECTION SCHEMAS
 ******************************************************************************/

/*
 * Users Collection
 * 
 * The complete set of all users in the system.
 */
schema Users
  users: UserID ‚á∏ User
where
  /* All user IDs in the mapping correspond to the user's id field */
  ‚àÄ uid: UserID ‚Ä¢ uid ‚àà dom users ‚áí users(uid).id = uid
  ‚àß
  /* Username uniqueness: No two distinct users can have the same username */
  ‚àÄ uid1, uid2: UserID ‚Ä¢ 
    uid1 ‚àà dom users ‚àß uid2 ‚àà dom users ‚àß uid1 ‚â† uid2 ‚áí 
    users(uid1).username ‚â† users(uid2).username


/*
 * Chats Collection
 * 
 * The complete set of all chats in the system.
 */
schema Chats
  chats: ChatID ‚á∏ Chat
where
  /* All chat IDs in the mapping correspond to the chat's id field */
  ‚àÄ cid: ChatID ‚Ä¢ cid ‚àà dom chats ‚áí chats(cid).id = cid


/*
 * Messages Collection
 * 
 * The complete set of all messages in the system.
 */
schema Messages
  messages: MessageID ‚á∏ Message
where
  /* All message IDs in the mapping correspond to the message's id field */
  ‚àÄ mid: MessageID ‚Ä¢ mid ‚àà dom messages ‚áí messages(mid).id = mid
  ‚àß
  /* Messages are ordered by creation time within each chat */
  /* This is enforced by database queries with ORDER BY created_at */
  true


/*
 * ChatParticipants Collection
 * 
 * The complete set of all chat participation relationships.
 */
schema ChatParticipants
  participants: ‚Ñô(ChatParticipant)
where
  /* Each (chat_id, user_id) pair is unique */
  ‚àÄ p1, p2: ChatParticipant ‚Ä¢ 
    p1 ‚àà participants ‚àß p2 ‚àà participants ‚àß 
    p1.chat_id = p2.chat_id ‚àß p1.user_id = p2.user_id ‚áí 
    p1 = p2


/*******************************************************************************
 * SECTION 4: REFERENTIAL INTEGRITY CONSTRAINTS
 ******************************************************************************/

/*
 * Database Referential Integrity
 * 
 * This schema defines the referential integrity constraints that ensure
 * data consistency across related entities. These constraints are enforced
 * by PostgreSQL foreign key constraints with CASCADE deletion.
 */
schema DatabaseIntegrity
  Users
  Chats
  Messages
  ChatParticipants
where
  /* Message Foreign Keys: All messages must reference valid chats and users */
  ‚àÄ mid: MessageID ‚Ä¢ mid ‚àà dom messages ‚áí
    (messages(mid).chat_id ‚àà dom chats ‚àß
     messages(mid).sender_user_id ‚àà dom users)
  ‚àß
  /* ChatParticipant Foreign Keys: All participants must reference valid chats and users */
  ‚àÄ p: ChatParticipant ‚Ä¢ p ‚àà participants ‚áí
    (p.chat_id ‚àà dom chats ‚àß p.user_id ‚àà dom users)
  ‚àß
  /* Chat Participation Constraint: Every chat must have at least 2 participants */
  /* This is an application-level invariant, not enforced by database schema */
  ‚àÄ cid: ChatID ‚Ä¢ cid ‚àà dom chats ‚áí
    #{p: ChatParticipant | p ‚àà participants ‚àß p.chat_id = cid} ‚â• 2
  ‚àß
  /* Message Sender Participation: Message senders must be participants of the chat */
  ‚àÄ mid: MessageID ‚Ä¢ mid ‚àà dom messages ‚áí
    ‚àÉ p: ChatParticipant ‚Ä¢ 
      p ‚àà participants ‚àß 
      p.chat_id = messages(mid).chat_id ‚àß 
      p.user_id = messages(mid).sender_user_id


/*******************************************************************************
 * SECTION 5: DERIVED RELATIONSHIPS AND QUERIES
 ******************************************************************************/

/*
 * Helper function: Get all participants of a chat
 */
chatParticipants: ChatID √ó ‚Ñô(ChatParticipant) ‚Üí ‚Ñô(UserID)
‚àÄ cid: ChatID; ps: ‚Ñô(ChatParticipant) ‚Ä¢
  chatParticipants(cid, ps) = 
    {p.user_id | p: ChatParticipant ‚Ä¢ p ‚àà ps ‚àß p.chat_id = cid}


/*
 * Helper function: Get all chats for a user
 */
userChats: UserID √ó ‚Ñô(ChatParticipant) ‚Üí ‚Ñô(ChatID)
‚àÄ uid: UserID; ps: ‚Ñô(ChatParticipant) ‚Ä¢
  userChats(uid, ps) = 
    {p.chat_id | p: ChatParticipant ‚Ä¢ p ‚àà ps ‚àß p.user_id = uid}


/*
 * Helper function: Get all messages in a chat
 */
chatMessages: ChatID √ó (MessageID ‚á∏ Message) ‚Üí seq Message
‚àÄ cid: ChatID; msgs: MessageID ‚á∏ Message ‚Ä¢
  chatMessages(cid, msgs) = 
    /* Returns messages ordered by created_at ascending */
    /* Formal sequence ordering omitted for brevity, but enforced by implementation */
    ‚ü®m: Message | ‚àÉ mid: MessageID ‚Ä¢ mid ‚àà dom msgs ‚àß msgs(mid) = m ‚àß m.chat_id = cid‚ü©


/*
 * Helper function: Get the last message in a chat
 */
lastMessage: ChatID √ó (MessageID ‚á∏ Message) ‚Üí Message
‚àÄ cid: ChatID; msgs: MessageID ‚á∏ Message ‚Ä¢
  let chatMsgs == chatMessages(cid, msgs) ‚Ä¢
    #chatMsgs > 0 ‚áí lastMessage(cid, msgs) = last chatMsgs


/*
 * Helper function: Check if user is participant in chat
 */
isParticipant: UserID √ó ChatID √ó ‚Ñô(ChatParticipant) ‚Üí ùîπ
‚àÄ uid: UserID; cid: ChatID; ps: ‚Ñô(ChatParticipant) ‚Ä¢
  isParticipant(uid, cid, ps) ‚áî 
    ‚àÉ p: ChatParticipant ‚Ä¢ p ‚àà ps ‚àß p.user_id = uid ‚àß p.chat_id = cid


/*
 * Helper function: Get the other participant in a 2-person chat
 */
otherParticipant: UserID √ó ChatID √ó ‚Ñô(ChatParticipant) √ó (UserID ‚á∏ User) ‚Üí User
‚àÄ uid: UserID; cid: ChatID; ps: ‚Ñô(ChatParticipant); us: UserID ‚á∏ User ‚Ä¢
  let participants == chatParticipants(cid, ps) ‚Ä¢
    uid ‚àà participants ‚àß #participants = 2 ‚áí
      ‚àÉ other_uid: UserID ‚Ä¢ 
        other_uid ‚àà participants ‚àß 
        other_uid ‚â† uid ‚àß
        otherParticipant(uid, cid, ps, us) = us(other_uid)


/*******************************************************************************
 * SECTION 6: DATA VALIDATION PREDICATES
 ******************************************************************************/

/*
 * Password Strength Validation
 * 
 * Validates password according to security requirements:
 * - Minimum 8 characters
 * - Additional constraints enforced by validators.ts
 */
validPassword: seq char ‚Üí ùîπ
‚àÄ pwd: seq char ‚Ä¢
  validPassword(pwd) ‚áî #pwd ‚â• MIN_PASSWORD_LENGTH


/*
 * Username Validation
 * 
 * Validates username according to requirements:
 * - Between 3 and 18 characters
 * - Alphanumeric with underscores allowed
 */
validUsername: seq char ‚Üí ùîπ
‚àÄ uname: seq char ‚Ä¢
  validUsername(uname) ‚áî 
    MIN_USERNAME_LENGTH ‚â§ #uname ‚àß 
    #uname ‚â§ MAX_USERNAME_LENGTH


/*
 * Message Content Validation
 * 
 * Validates message content:
 * - Non-empty
 * - Maximum 355 characters
 */
validMessageContent: seq char ‚Üí ùîπ
‚àÄ content: seq char ‚Ä¢
  validMessageContent(content) ‚áî 
    1 ‚â§ #content ‚àß #content ‚â§ MAX_MESSAGE_LENGTH


/*******************************************************************************
 * SECTION 7: DATABASE STATE SCHEMA
 ******************************************************************************/

/*
 * Complete Database State
 * 
 * This schema represents the entire state of the WhatsApp Clone database
 * at any point in time, including all entities and relationships with
 * referential integrity constraints.
 */
schema DatabaseState
  DatabaseIntegrity
where
  /* All constraints from DatabaseIntegrity are inherited */
  /* Additional system-wide invariants can be added here */
  true


/*******************************************************************************
 * SECTION 8: SAMPLE DATA INVARIANTS
 ******************************************************************************/

/*
 * Sample Database State
 * 
 * This schema defines the initial state with sample users and chats
 * as specified in the resetDb() function in db.ts.
 */
schema SampleDatabaseState
  DatabaseState
where
  /* Sample database has 5 users */
  #(dom users) = 5
  ‚àß
  /* Sample database has 4 chats */
  #(dom chats) = 4
  ‚àß
  /* Each sample chat has exactly 2 participants */
  ‚àÄ cid: ChatID ‚Ä¢ cid ‚àà dom chats ‚áí
    #{p: ChatParticipant | p ‚àà participants ‚àß p.chat_id = cid} = 2
  ‚àß
  /* User with ID 1 ('ray') participates in all 4 chats */
  ‚àÉ uid: UserID ‚Ä¢ uid ‚àà dom users ‚àß
    #{p: ChatParticipant | p ‚àà participants ‚àß p.user_id = uid} = 4


/*******************************************************************************
 * SECTION 9: DATA LAYER OPERATIONS (Queries Only)
 ******************************************************************************/

/*
 * Operation: Find User by Username
 * 
 * Corresponds to: UsersProvider.findByUsername(username)
 */
schema FindUserByUsername
  ŒûDatabaseState
  username?: Username
  user!: User
where
  ‚àÉ uid: UserID ‚Ä¢ uid ‚àà dom users ‚àß 
    users(uid).username = username? ‚àß
    user! = users(uid)


/*
 * Operation: Find User by ID
 * 
 * Corresponds to: UsersProvider.findById(userId)
 */
schema FindUserById
  ŒûDatabaseState
  userId?: UserID
  user!: User
where
  userId? ‚àà dom users ‚àß
  user! = users(userId?)


/*
 * Operation: Find All Users Except Current
 * 
 * Corresponds to: UsersProvider.findAllExcept(userId)
 */
schema FindAllUsersExcept
  ŒûDatabaseState
  currentUserId?: UserID
  users!: seq User
where
  users! = ‚ü®users(uid) | uid: UserID ‚Ä¢ uid ‚àà dom users ‚àß uid ‚â† currentUserId?‚ü©


/*
 * Operation: Find Chats by User
 * 
 * Corresponds to: ChatsProvider.findChatsByUser(userId)
 */
schema FindChatsByUser
  ŒûDatabaseState
  userId?: UserID
  chats!: seq Chat
where
  chats! = ‚ü®chats(cid) | cid: ChatID ‚Ä¢ cid ‚àà userChats(userId?, participants)‚ü©


/*
 * Operation: Find Chat by ID and User
 * 
 * Corresponds to: ChatsProvider.findChatByUser({chatId, userId})
 * Returns chat only if user is a participant
 */
schema FindChatByUser
  ŒûDatabaseState
  chatId?: ChatID
  userId?: UserID
  chat!: Chat
where
  chatId? ‚àà dom chats ‚àß
  isParticipant(userId?, chatId?, participants) ‚àß
  chat! = chats(chatId?)


/*
 * Operation: Find Messages by Chat with Pagination
 * 
 * Corresponds to: ChatsProvider.findMessagesByChat({chatId, limit, after})
 */
schema FindMessagesByChat
  ŒûDatabaseState
  chatId?: ChatID
  limit?: ‚Ñï
  after?: DateTime
  messages!: seq Message
  hasMore!: ùîπ
  cursor!: DateTime
where
  chatId? ‚àà dom chats ‚àß
  limit? > 0 ‚àß
  /* Messages filtered by chat and optionally by timestamp */
  let allChatMessages == chatMessages(chatId?, messages) ‚Ä¢
    let filteredMessages == 
      after? ‚â† null ‚áí 
        ‚ü®m: Message | m ‚àà allChatMessages ‚àß m.created_at < after?‚ü©
      ‚äï
        allChatMessages ‚Ä¢
    /* Take limit messages in descending order */
    #filteredMessages ‚â§ limit? ‚áí
      (messages! = filteredMessages ‚àß hasMore! = false)
    ‚äï
      (messages! = take(limit?, filteredMessages) ‚àß hasMore! = true) ‚àß
    /* Cursor is the created_at of the last message */
    #messages! > 0 ‚áí cursor! = (last messages!).created_at


/*
 * Operation: Get Last Message in Chat
 * 
 * Corresponds to: ChatsProvider.lastMessage(chatId)
 */
schema GetLastMessage
  ŒûDatabaseState
  chatId?: ChatID
  message!: Message
where
  chatId? ‚àà dom chats ‚àß
  message! = lastMessage(chatId?, messages)


/*
 * Operation: Get Chat Participants
 * 
 * Corresponds to: ChatsProvider.participants(chatId)
 */
schema GetChatParticipants
  ŒûDatabaseState
  chatId?: ChatID
  participants!: seq User
where
  chatId? ‚àà dom chats ‚àß
  participants! = ‚ü®users(uid) | uid: UserID ‚Ä¢ uid ‚àà chatParticipants(chatId?, participants)‚ü©


/*
 * Operation: Check if User is Participant
 * 
 * Corresponds to: ChatsProvider.isParticipant({chatId, userId})
 */
schema CheckIsParticipant
  ŒûDatabaseState
  chatId?: ChatID
  userId?: UserID
  result!: ùîπ
where
  result! = isParticipant(userId?, chatId?, participants)


/*******************************************************************************
 * END OF DATA MODEL SPECIFICATION
 ******************************************************************************/

/*
 * NOTES ON IMPLEMENTATION MAPPING:
 * 
 * 1. Database Connection Pool:
 *    - Managed by pg.Pool in db.ts
 *    - Connection pooling not modeled in formal spec
 * 
 * 2. DataLoader Caching:
 *    - DataLoader provides request-scoped caching
 *    - Not modeled in formal spec as it's a performance optimization
 *    - Does not affect logical semantics
 * 
 * 3. SQL Template Strings:
 *    - Used for parameterized queries to prevent SQL injection
 *    - Security mechanism, not modeled in formal spec
 * 
 * 4. Auto-incrementing IDs:
 *    - PostgreSQL SERIAL type generates unique IDs
 *    - Modeled abstractly as distinct identifier types
 * 
 * 5. Timestamp Generation:
 *    - Database generates timestamps with DEFAULT NOW()
 *    - Modeled as DateTime type (Unix timestamp)
 * 
 * 6. Cascade Deletion:
 *    - ON DELETE CASCADE ensures referential integrity
 *    - Will be modeled in operations.zpp for delete operations
 */

/*******************************************************************************
 * WhatsApp Clone - Core Operations Formal Specification (Z++)
 * 
 * This specification formalizes the core backend operations including:
 * - Authentication operations (signIn, signUp)
 * - Data mutation operations (addMessage, addChat, removeChat)
 * - Data retrieval operations (queries)
 * 
 * All operations maintain system invariants and handle error conditions.
 ******************************************************************************/

include "data_model.zpp"
include "system_state.zpp"


/*******************************************************************************
 * SECTION 1: AUTHENTICATION OPERATIONS
 ******************************************************************************/

/*
 * Operation: Sign In
 * 
 * Authenticates a user with username and password.
 * Sets authentication cookie in response on success.
 * 
 * Corresponds to: Auth.signIn({username, password})
 * GraphQL Mutation: signIn(username: String!, password: String!): User
 */
schema SignIn
  ŒîApplicationState
  ŒîAuthContext
  username?: Username
  password?: seq char
  user!: User
  success!: ùîπ
where
  /* Pre-conditions */
  validUsername(username?) ‚àß
  #password? ‚â• MIN_PASSWORD_LENGTH
  ‚àß
  /* Find user by username */
  (‚àÉ uid: UserID ‚Ä¢ uid ‚àà dom users ‚àß users(uid).username = username? ‚áí
    let targetUser == users(uid) ‚Ä¢
      /* Verify password using bcrypt */
      /* bcrypt.compareSync(password?, targetUser.password) */
      (/* password matches */ ‚áí
        (/* Generate JWT token */
         let token == signJWT(username?, authConfig.jwtSecret) ‚Ä¢
           /* Set auth cookie in response */
           response'.cookies = response.cookies ‚å¢ 
             ‚ü®AuthCookie' | 
               name = "authToken" ‚àß 
               value = token ‚àß 
               maxAge = authConfig.tokenExpiration ‚àß
               httpOnly = true‚ü©
           ‚àß
           /* Update session state */
           currentUser' = uid ‚àß
           authenticated' = true ‚àß
           /* Return user */
           user! = targetUser ‚àß
           success! = true
        )
      ‚äï
        /* Password does not match */
        (success! = false ‚àß
         /* Error: "password is incorrect" */
         user! = null)
      )
  )
  ‚äï
    /* User not found */
    (success! = false ‚àß
     /* Error: "user not found" */
     user! = null)
  ‚àß
  /* Database state unchanged (read-only operation) */
  DatabaseState' = DatabaseState


/*
 * Operation: Sign Up
 * 
 * Creates a new user account with validation.
 * Automatically signs in the new user on success.
 * 
 * Corresponds to: Auth.signUp({name, username, password, passwordConfirm})
 * GraphQL Mutation: signUp(name: String!, username: String!, 
 *                           password: String!, passwordConfirm: String!): User
 */
schema SignUp
  ŒîApplicationState
  ŒîAuthContext
  name?: UserName
  username?: Username
  password?: seq char
  passwordConfirm?: seq char
  user!: User
  newUserId!: UserID
  success!: ùîπ
where
  /* Pre-conditions: Input validation */
  validUsername(username?) ‚àß
  MIN_NAME_LENGTH ‚â§ #name? ‚àß #name? ‚â§ MAX_NAME_LENGTH ‚àß
  validPassword(password?) ‚àß
  password? = passwordConfirm?
  ‚àß
  /* Check username availability */
  (¬¨(‚àÉ uid: UserID ‚Ä¢ uid ‚àà dom users ‚àß users(uid).username = username?) ‚áí
    /* Username is available */
    (/* Generate new user ID */
     newUserId! ‚àâ dom users ‚àß
     /* Hash password with bcrypt */
     let hashedPassword == /* bcrypt.hashSync(password?, 8) */ ‚Ä¢
       /* Create new user */
       let newUser == User' |
         newUser.id = newUserId! ‚àß
         newUser.username = username? ‚àß
         newUser.name = name? ‚àß
         newUser.password = hashedPassword ‚àß
         newUser.picture = /* default picture URL */ ‚Ä¢
         /* Add user to database */
         users' = users ‚äï {newUserId! ‚Ü¶ newUser} ‚àß
         /* Automatically sign in the new user */
         let token == signJWT(username?, authConfig.jwtSecret) ‚Ä¢
           response'.cookies = response.cookies ‚å¢ 
             ‚ü®AuthCookie' | 
               name = "authToken" ‚àß 
               value = token ‚àß 
               maxAge = authConfig.tokenExpiration ‚àß
               httpOnly = true‚ü© ‚àß
           currentUser' = newUserId! ‚àß
           authenticated' = true ‚àß
           user! = newUser ‚àß
           success! = true
    )
  )
  ‚äï
    /* Username already exists */
    (success! = false ‚àß
     /* Error: "username already exists" */
     user! = null ‚àß
     DatabaseState' = DatabaseState)
  ‚àß
  /* Maintain database integrity */
  ‚àÄ uid: UserID ‚Ä¢ uid ‚àà dom users' ‚áí
    (uid ‚àà dom users ‚à® uid = newUserId!)


/*
 * Operation: Get Current User
 * 
 * Retrieves the currently authenticated user from session.
 * Verifies JWT token if present and caches the result.
 * 
 * Corresponds to: Auth.currentUser()
 * GraphQL Query: me: User
 */
schema GetCurrentUser
  ŒûApplicationState
  ŒûAuthContext
  user!: User ‚à™ {null}
where
  /* Check if user already cached in session */
  (currentUser ‚â† null ‚áí
    user! = users(currentUser)
  )
  ‚äï
    /* Check for auth token in cookies */
    ("authToken" ‚àà dom request.cookies ‚áí
      let token == request.cookies("authToken") ‚Ä¢
        let username == verifyJWT(token, authConfig.jwtSecret, /* current time */) ‚Ä¢
          (username ‚â† null ‚áí
            /* Find user by username */
            (‚àÉ uid: UserID ‚Ä¢ uid ‚àà dom users ‚àß users(uid).username = username ‚áí
              user! = users(uid)
            )
          )
          ‚äï
            /* Token invalid or expired */
            user! = null
    )
    ‚äï
      /* No auth token present */
      user! = null


/*******************************************************************************
 * SECTION 2: CHAT QUERY OPERATIONS
 ******************************************************************************/

/*
 * Operation: Get Chats for User
 * 
 * Retrieves all chats where the current user is a participant.
 * 
 * Corresponds to: Query.chats resolver
 * GraphQL Query: chats: [Chat!]!
 */
schema GetChats
  ŒûApplicationState
  AuthContext
  chats!: seq Chat
where
  /* Pre-condition: User must be authenticated */
  authenticated = true ‚àß currentUser ‚â† null
  ‚áí
    /* Get all chats for current user */
    chats! = ‚ü®chats(cid) | cid: ChatID ‚Ä¢ 
      cid ‚àà userChats(currentUser, participants)‚ü©
  ‚äï
    /* Not authenticated - return empty list */
    chats! = ‚ü®‚ü©


/*
 * Operation: Get Single Chat
 * 
 * Retrieves a specific chat if the current user is a participant.
 * 
 * Corresponds to: Query.chat(chatId) resolver
 * GraphQL Query: chat(chatId: ID!): Chat
 */
schema GetChat
  ŒûApplicationState
  AuthContext
  chatId?: ChatID
  chat!: Chat ‚à™ {null}
where
  /* Pre-condition: User must be authenticated */
  authenticated = true ‚àß currentUser ‚â† null
  ‚áí
    (/* Check if chat exists and user is participant */
     chatId? ‚àà dom chats ‚àß 
     isParticipant(currentUser, chatId?, participants)
     ‚áí
       chat! = chats(chatId?)
     ‚äï
       /* Chat not found or not a participant */
       chat! = null
    )
  ‚äï
    /* Not authenticated */
    chat! = null


/*
 * Operation: Get Chat Messages with Pagination
 * 
 * Retrieves messages for a chat with pagination support.
 * Messages returned in descending order (newest first).
 * 
 * Corresponds to: Chat.messages resolver
 * GraphQL Field: Chat.messages(limit: Int!, after: Float): MessagesResult!
 */
schema GetChatMessages
  ŒûApplicationState
  AuthContext
  chatId?: ChatID
  limit?: ‚Ñï
  after?: DateTime ‚à™ {null}
  messages!: seq Message
  hasMore!: ùîπ
  cursor!: DateTime ‚à™ {null}
where
  /* Pre-condition: User must be authenticated and be participant */
  authenticated = true ‚àß 
  currentUser ‚â† null ‚àß
  chatId? ‚àà dom chats ‚àß
  isParticipant(currentUser, chatId?, participants)
  ‚áí
    (/* Get all messages for chat */
     let allMessages == chatMessages(chatId?, messages) ‚Ä¢
       /* Filter by cursor if provided */
       let filteredMessages == 
         (after? ‚â† null ‚áí 
           ‚ü®m: Message | m ‚àà allMessages ‚àß m.created_at < after?‚ü©
         ‚äï
           allMessages) ‚Ä¢
         /* Reverse order (newest first) and apply limit */
         let reversedMessages == rev filteredMessages ‚Ä¢
           (#reversedMessages ‚â§ limit? ‚áí
             (messages! = take(#reversedMessages, reversedMessages) ‚àß
              hasMore! = false ‚àß
              cursor! = null)
           ‚äï
             (messages! = take(limit?, reversedMessages) ‚àß
              hasMore! = true ‚àß
              cursor! = (last messages!).created_at)
           )
    )
  ‚äï
    /* Not authorized */
    (messages! = ‚ü®‚ü© ‚àß hasMore! = false ‚àß cursor! = null)


/*
 * Operation: Get Users (excluding current user)
 * 
 * Retrieves all users except the current user.
 * Used for creating new chats.
 * 
 * Corresponds to: Query.users resolver
 * GraphQL Query: users: [User!]!
 */
schema GetUsers
  ŒûApplicationState
  AuthContext
  users!: seq User
where
  /* Pre-condition: User must be authenticated */
  authenticated = true ‚àß currentUser ‚â† null
  ‚áí
    users! = ‚ü®users(uid) | uid: UserID ‚Ä¢ 
      uid ‚àà dom users ‚àß uid ‚â† currentUser‚ü©
  ‚äï
    /* Not authenticated - return empty list */
    users! = ‚ü®‚ü©


/*******************************************************************************
 * SECTION 3: MESSAGE MUTATION OPERATIONS
 ******************************************************************************/

/*
 * Operation: Add Message
 * 
 * Adds a new message to a chat.
 * Publishes messageAdded event to subscribers.
 * 
 * Corresponds to: Mutation.addMessage(chatId, content)
 * GraphQL Mutation: addMessage(chatId: ID!, content: String!): Message
 */
schema AddMessage
  ŒîApplicationState
  AuthContext
  chatId?: ChatID
  content?: MessageContent
  message!: Message
  newMessageId!: MessageID
  success!: ùîπ
where
  /* Pre-conditions */
  authenticated = true ‚àß
  currentUser ‚â† null ‚àß
  validMessageContent(content?) ‚àß
  chatId? ‚àà dom chats ‚àß
  isParticipant(currentUser, chatId?, participants)
  ‚áí
    (/* Generate new message ID */
     newMessageId! ‚àâ dom messages ‚àß
     /* Create new message */
     let newMessage == Message' |
       newMessage.id = newMessageId! ‚àß
       newMessage.content = content? ‚àß
       newMessage.created_at = /* current timestamp */ ‚àß
       newMessage.chat_id = chatId? ‚àß
       newMessage.sender_user_id = currentUser ‚Ä¢
       /* Add message to database */
       messages' = messages ‚äï {newMessageId! ‚Ü¶ newMessage} ‚àß
       message! = newMessage ‚àß
       success! = true ‚àß
       /* Publish event to PubSub */
       let event == PubSubEvent' |
         event.eventType = messageAdded ‚àß
         event.payload = newMessageId! ‚àß
         event.timestamp = newMessage.created_at ‚Ä¢
         pubsubState'.eventQueue = pubsubState.eventQueue ‚å¢ ‚ü®event‚ü©
    )
  ‚äï
    /* Pre-conditions not met */
    (success! = false ‚àß
     message! = null ‚àß
     DatabaseState' = DatabaseState ‚àß
     pubsubState' = pubsubState)
  ‚àß
  /* Rest of state unchanged */
  users' = users ‚àß
  chats' = chats ‚àß
  participants' = participants


/*******************************************************************************
 * SECTION 4: CHAT MUTATION OPERATIONS
 ******************************************************************************/

/*
 * Operation: Add Chat
 * 
 * Creates a new chat between current user and recipient.
 * Checks if chat already exists between the two users.
 * 
 * Corresponds to: Mutation.addChat(recipientId)
 * GraphQL Mutation: addChat(recipientId: ID!): Chat
 */
schema AddChat
  ŒîApplicationState
  AuthContext
  recipientId?: UserID
  chat!: Chat
  newChatId!: ChatID
  success!: ùîπ
where
  /* Pre-conditions */
  authenticated = true ‚àß
  currentUser ‚â† null ‚àß
  recipientId? ‚àà dom users ‚àß
  recipientId? ‚â† currentUser
  ‚áí
    (/* Check if chat already exists between these users */
     let existingChats == userChats(currentUser, participants) ‚à©
                          userChats(recipientId?, participants) ‚Ä¢
       (#existingChats = 0 ‚áí
         /* No existing chat - create new one */
         (newChatId! ‚àâ dom chats ‚àß
          /* Create new chat */
          let newChat == Chat' | newChat.id = newChatId! ‚Ä¢
            chats' = chats ‚äï {newChatId! ‚Ü¶ newChat} ‚àß
            /* Add participants */
            let p1 == ChatParticipant' |
              p1.chat_id = newChatId! ‚àß p1.user_id = currentUser ‚Ä¢
            let p2 == ChatParticipant' |
              p2.chat_id = newChatId! ‚àß p2.user_id = recipientId? ‚Ä¢
              participants' = participants ‚à™ {p1, p2} ‚àß
              chat! = newChat ‚àß
              success! = true ‚àß
              /* Publish event to PubSub */
              let event == PubSubEvent' |
                event.eventType = chatAdded ‚àß
                event.payload = newChatId! ‚àß
                event.timestamp = /* current time */ ‚Ä¢
                pubsubState'.eventQueue = pubsubState.eventQueue ‚å¢ ‚ü®event‚ü©
         )
       ‚äï
         /* Chat already exists - return existing chat */
         let existingChatId == /* first element of existingChats */ ‚Ä¢
           (chat! = chats(existingChatId) ‚àß
            success! = true ‚àß
            DatabaseState' = DatabaseState ‚àß
            pubsubState' = pubsubState)
       )
    )
  ‚äï
    /* Pre-conditions not met */
    (success! = false ‚àß
     chat! = null ‚àß
     DatabaseState' = DatabaseState ‚àß
     pubsubState' = pubsubState)
  ‚àß
  /* Rest of state unchanged */
  users' = users ‚àß
  messages' = messages


/*
 * Operation: Remove Chat
 * 
 * Removes a chat and all associated messages.
 * Enforced by database CASCADE deletion.
 * 
 * Corresponds to: Mutation.removeChat(chatId)
 * GraphQL Mutation: removeChat(chatId: ID!): ID
 */
schema RemoveChat
  ŒîApplicationState
  AuthContext
  chatId?: ChatID
  removedChatId!: ChatID ‚à™ {null}
  success!: ùîπ
where
  /* Pre-conditions */
  authenticated = true ‚àß
  currentUser ‚â† null ‚àß
  chatId? ‚àà dom chats ‚àß
  isParticipant(currentUser, chatId?, participants)
  ‚áí
    (/* Remove chat */
     chats' = chats ‚äñ {chatId?} ‚àß
     /* Remove all messages in this chat (CASCADE) */
     messages' = {mid ‚Ü¶ msg | mid: MessageID; msg: Message ‚Ä¢
       mid ‚àà dom messages ‚àß msg = messages(mid) ‚àß msg.chat_id ‚â† chatId?} ‚àß
     /* Remove all participants (CASCADE) */
     participants' = {p: ChatParticipant | 
       p ‚àà participants ‚àß p.chat_id ‚â† chatId?} ‚àß
     removedChatId! = chatId? ‚àß
     success! = true ‚àß
     /* Publish event to PubSub */
     let event == PubSubEvent' |
       event.eventType = chatRemoved ‚àß
       event.payload = chatId? ‚àß
       event.timestamp = /* current time */ ‚Ä¢
       pubsubState'.eventQueue = pubsubState.eventQueue ‚å¢ ‚ü®event‚ü©
    )
  ‚äï
    /* Pre-conditions not met */
    (success! = false ‚àß
     removedChatId! = null ‚àß
     DatabaseState' = DatabaseState ‚àß
     pubsubState' = pubsubState)
  ‚àß
  /* Rest of state unchanged */
  users' = users


/*******************************************************************************
 * SECTION 5: SUBSCRIPTION OPERATIONS
 ******************************************************************************/

/*
 * Operation: Subscribe to Message Added
 * 
 * Creates a subscription to receive messageAdded events.
 * Only receives events for chats where user is a participant.
 * 
 * Corresponds to: Subscription.messageAdded
 * GraphQL Subscription: messageAdded: Message!
 */
schema SubscribeMessageAdded
  ŒîApplicationState
  AuthContext
  subscriptionId!: seq char
  success!: ùîπ
where
  /* Pre-condition: User must be authenticated */
  authenticated = true ‚àß currentUser ‚â† null
  ‚áí
    (/* Create subscription with filter */
     let filter == Œª event: PubSubEvent; session: SessionState ‚Ä¢
       event.eventType = messageAdded ‚áí
         let messageId == event.payload ‚Ä¢
           messageId ‚àà dom messages ‚áí
             let message == messages(messageId) ‚Ä¢
               isParticipant(session.currentUser, message.chat_id, participants) ‚Ä¢
     /* Generate unique subscription ID */
     subscriptionId! ‚àâ dom pubsubState.subscriptions ‚àß
     /* Create subscription */
     let newSub == ActiveSubscription' |
       newSub.subscriptionId = subscriptionId! ‚àß
       newSub.sessionId = sessionId ‚àß
       newSub.eventType = messageAdded ‚àß
       newSub.filter = filter ‚àß
       newSub.createdAt = /* current time */ ‚Ä¢
       pubsubState'.subscriptions = 
         pubsubState.subscriptions ‚äï {subscriptionId! ‚Ü¶ newSub} ‚àß
       success! = true
    )
  ‚äï
    /* Not authenticated */
    (success! = false ‚àß
     pubsubState' = pubsubState)
  ‚àß
  /* Database state unchanged */
  DatabaseState' = DatabaseState


/*
 * Operation: Subscribe to Chat Added
 * 
 * Creates a subscription to receive chatAdded events.
 * Only receives events for chats where user is a participant.
 * 
 * Corresponds to: Subscription.chatAdded
 * GraphQL Subscription: chatAdded: Chat!
 */
schema SubscribeChatAdded
  ŒîApplicationState
  AuthContext
  subscriptionId!: seq char
  success!: ùîπ
where
  /* Pre-condition: User must be authenticated */
  authenticated = true ‚àß currentUser ‚â† null
  ‚áí
    (/* Create subscription with filter */
     let filter == Œª event: PubSubEvent; session: SessionState ‚Ä¢
       event.eventType = chatAdded ‚áí
         let chatId == event.payload ‚Ä¢
           isParticipant(session.currentUser, chatId, participants) ‚Ä¢
     /* Generate unique subscription ID */
     subscriptionId! ‚àâ dom pubsubState.subscriptions ‚àß
     /* Create subscription (similar to SubscribeMessageAdded) */
     success! = true ‚àß
     /* Implementation details omitted for brevity */
     true
    )
  ‚äï
    /* Not authenticated */
    (success! = false ‚àß
     pubsubState' = pubsubState)
  ‚àß
  /* Database state unchanged */
  DatabaseState' = DatabaseState


/*
 * Operation: Subscribe to Chat Removed
 * 
 * Creates a subscription to receive chatRemoved events.
 * Only receives events for chats where user was a participant.
 * 
 * Corresponds to: Subscription.chatRemoved
 * GraphQL Subscription: chatRemoved: ID!
 */
schema SubscribeChatRemoved
  ŒîApplicationState
  AuthContext
  subscriptionId!: seq char
  success!: ùîπ
where
  /* Similar to SubscribeChatAdded */
  /* Implementation details omitted for brevity */
  true


/*******************************************************************************
 * SECTION 6: OPERATION COMPOSITION AND ERROR HANDLING
 ******************************************************************************/

/*
 * Generic Error Response
 * 
 * Represents an error that can be returned by any operation.
 */
schema OperationError
  errorCode: seq char
  errorMessage: seq char
  timestamp: DateTime
where
  #errorCode > 0 ‚àß
  #errorMessage > 0


/*
 * Common error codes used throughout the system:
 */
given
  ERROR_UNAUTHENTICATED == "UNAUTHENTICATED"
  ERROR_UNAUTHORIZED == "UNAUTHORIZED"
  ERROR_NOT_FOUND == "NOT_FOUND"
  ERROR_INVALID_INPUT == "INVALID_INPUT"
  ERROR_DUPLICATE_ENTRY == "DUPLICATE_ENTRY"
  ERROR_INTERNAL_ERROR == "INTERNAL_ERROR"


/*
 * Operation Result (Generic)
 * 
 * Generic result type for operations that can succeed or fail.
 */
schema OperationResult[T]
  success: ùîπ
  data: T ‚à™ {null}
  error: OperationError ‚à™ {null}
where
  /* If successful, data is not null and error is null */
  success = true ‚áí (data ‚â† null ‚àß error = null)
  ‚àß
  /* If failed, data is null and error is not null */
  success = false ‚áí (data = null ‚àß error ‚â† null)


/*
 * Authorization Check Helper
 * 
 * Generic authorization check for operations requiring authentication.
 */
schema RequireAuthentication
  AuthContext
  authorized!: ùîπ
where
  authorized! = (authenticated = true ‚àß currentUser ‚â† null)


/*
 * Authorization Check for Chat Access
 * 
 * Checks if current user can access a specific chat.
 */
schema RequireChatAccess
  AuthContext
  DatabaseState
  chatId?: ChatID
  authorized!: ùîπ
where
  chatId? ‚àà dom chats ‚àß
  authenticated = true ‚àß
  currentUser ‚â† null
  ‚áí
    authorized! = isParticipant(currentUser, chatId?, participants)
  ‚äï
    authorized! = false


/*******************************************************************************
 * SECTION 7: TRANSACTION SEMANTICS
 ******************************************************************************/

/*
 * Database Transaction State
 * 
 * Represents a database transaction in progress.
 */
schema Transaction
  transactionId: seq char
  operations: seq (seq char)  // Operation names
  startTime: DateTime
  isolationLevel: seq char
  status: seq char
where
  #transactionId > 0 ‚àß
  status ‚àà {"active", "committed", "rolled_back"} ‚àß
  isolationLevel ‚àà {"read_uncommitted", "read_committed", 
                     "repeatable_read", "serializable"}


/*
 * Atomic Operation Execution
 * 
 * Ensures that operations are executed atomically.
 * If any operation fails, all changes are rolled back.
 */
schema AtomicExecution[Op]
  transaction: Transaction
  initialState: ApplicationState
  finalState: ApplicationState
  operation: Op
  committed: ùîπ
where
  transaction.status = "active" ‚áí
    (/* Execute operation */
     committed = true ‚áí
       (finalState = /* result of operation */ ‚àß
        transaction.status = "committed")
     ‚äï
       /* Rollback on failure */
       (finalState = initialState ‚àß
        transaction.status = "rolled_back")
    )


/*******************************************************************************
 * END OF OPERATIONS SPECIFICATION
 ******************************************************************************/

/*
 * NOTES ON IMPLEMENTATION:
 * 
 * 1. Password Hashing:
 *    - bcrypt.hashSync(password, 8) for signup
 *    - bcrypt.compareSync(password, hash) for signin
 *    - Computational cost parameter: 8 rounds
 * 
 * 2. JWT Token Generation:
 *    - jwt.sign(username, secret) creates token
 *    - jwt.verify(token, secret) validates token
 *    - Tokens stored in HTTP-only cookies
 * 
 * 3. Transaction Guarantees:
 *    - PostgreSQL provides ACID transactions
 *    - All mutations wrapped in database transactions
 *    - Rollback on error maintains consistency
 * 
 * 4. Authorization Model:
 *    - Current user extracted from JWT token
 *    - Operations check authentication status
 *    - Chat access requires participant membership
 * 
 * 5. Real-time Updates:
 *    - PubSub events published after successful mutations
 *    - Subscription filters ensure proper event routing
 *    - WebSocket connections managed by Apollo Server
 * 
 * 6. Error Handling:
 *    - All operations return success indicator
 *    - Errors include descriptive messages
 *    - GraphQL errors propagated to client
 * 
 * 7. Pagination:
 *    - Cursor-based pagination for messages
 *    - Efficient for large message histories
 *    - Supports infinite scroll pattern
 */

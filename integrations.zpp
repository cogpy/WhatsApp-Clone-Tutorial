/*******************************************************************************
 * WhatsApp Clone - External Integration Contracts Formal Specification (Z++)
 * 
 * This specification formalizes the contracts for external service integrations
 * and event-driven components, including:
 * - Unsplash API integration for random photos
 * - GraphQL subscription event handling
 * - PostgreSQL LISTEN/NOTIFY for PubSub
 * - External REST API data sources
 ******************************************************************************/

include "data_model.zpp"
include "system_state.zpp"
include "operations.zpp"


/*******************************************************************************
 * SECTION 1: UNSPLASH API INTEGRATION
 ******************************************************************************/

/*
 * Unsplash Photo Response
 * 
 * Represents the structure of a photo returned by Unsplash API.
 * The full API response contains many more fields, but we only
 * model the fields used by the application.
 */
schema UnsplashPhoto
  id: seq char
  urls: seq char ‚á∏ URL
  alt_description: seq char
  width: ‚Ñï
  height: ‚Ñï
where
  #id > 0 ‚àß
  "regular" ‚àà dom urls ‚àß  // Regular size URL
  "small" ‚àà dom urls ‚àß     // Small size URL
  "thumb" ‚àà dom urls       // Thumbnail URL


/*
 * Unsplash API Request
 * 
 * Represents a request to the Unsplash API.
 */
schema UnsplashAPIRequest
  endpoint: seq char
  method: seq char
  headers: seq char ‚á∏ seq char
  queryParams: seq char ‚á∏ seq char
where
  method ‚àà {"GET", "POST", "PUT", "DELETE"} ‚àß
  "Authorization" ‚àà dom headers


/*
 * Unsplash API Response
 * 
 * Generic response structure from Unsplash API.
 */
schema UnsplashAPIResponse
  statusCode: ‚Ñï
  headers: seq char ‚á∏ seq char
  body: seq char
  success: ùîπ
where
  statusCode ‚â• 100 ‚àß statusCode < 600 ‚àß
  (statusCode ‚â• 200 ‚àß statusCode < 300 ‚áî success = true)


/*
 * Operation: Get Random Photo from Unsplash
 * 
 * Fetches a random photo URL from Unsplash API.
 * Used to provide default chat pictures.
 * 
 * Corresponds to: UnsplashApi.getRandomPhoto()
 * Endpoint: GET https://api.unsplash.com/photos/random
 */
schema GetRandomPhoto
  ŒûApplicationState
  ExternalAPIState
  photo!: UnsplashPhoto ‚à™ {null}
  photoURL!: URL ‚à™ {null}
  success!: ùîπ
where
  /* Build API request */
  let request == UnsplashAPIRequest' |
    request.endpoint = "/photos/random" ‚àß
    request.method = "GET" ‚àß
    request.headers = {"Authorization" ‚Ü¶ 
      ("Client-ID " ‚å¢ externalAPIs.unsplashConfig.accessKey)} ‚àß
    request.queryParams = {
      "query" ‚Ü¶ "people",
      "orientation" ‚Ü¶ "portrait"
    } ‚Ä¢
    /* Check cache first */
    let cacheKey == externalAPIs.unsplashConfig.baseURL ‚å¢ 
                    request.endpoint ‚å¢ "?query=people&orientation=portrait" ‚Ä¢
      (cacheKey ‚àà dom externalAPIs.unsplashCache.urlCache ‚áí
        /* Cache hit */
        let (cachedResponse, timestamp) == 
          externalAPIs.unsplashCache.urlCache(cacheKey) ‚Ä¢
          (/* Check if cache is still valid */
           /* current_time - timestamp < cacheTTL */ ‚áí
             (/* Parse cached response */
              photo! = /* deserialize(cachedResponse) */ ‚àß
              photoURL! = photo!.urls("regular") ‚àß
              success! = true)
           ‚äï
             /* Cache expired - fetch fresh data */
             /* Make HTTP request (detailed below) */
             true
          )
      )
      ‚äï
        /* Cache miss - make HTTP request */
        let response == /* HTTP GET request */ ‚Ä¢
          (response.success = true ‚áí
            (/* Parse JSON response */
             photo! = /* JSON.parse(response.body) */ ‚àß
             photoURL! = photo!.urls("regular") ‚àß
             success! = true ‚àß
             /* Update cache */
             externalAPIs'.unsplashCache.urlCache = 
               externalAPIs.unsplashCache.urlCache ‚äï 
               {cacheKey ‚Ü¶ (response.body, /* current_time */)}
            )
          ‚äï
            /* Request failed */
            (photo! = null ‚àß
             photoURL! = null ‚àß
             success! = false)
          )


/*
 * Unsplash API Rate Limiting
 * 
 * Unsplash API has rate limits that must be respected.
 */
schema UnsplashRateLimits
  requestsPerHour: ‚Ñï
  remainingRequests: ‚Ñï
  resetTime: DateTime
where
  requestsPerHour = 50 ‚àß  // Demo/Development tier
  remainingRequests ‚â§ requestsPerHour


/*
 * Operation: Handle Rate Limit Exceeded
 * 
 * Handles the case when Unsplash API rate limit is exceeded.
 * Falls back to default/cached photo URLs.
 */
schema HandleRateLimitExceeded
  ŒûApplicationState
  fallbackURL!: URL
where
  /* Use a default fallback URL when rate limited */
  fallbackURL! = "https://randomuser.me/api/portraits/thumb/lego/1.jpg"


/*******************************************************************************
 * SECTION 2: POSTGRESQL PUBSUB INTEGRATION
 ******************************************************************************/

/*
 * PostgreSQL NOTIFY Payload
 * 
 * Payload sent with PostgreSQL NOTIFY command.
 * Contains serialized event data.
 */
schema PostgresNotifyPayload
  channel: seq char
  payload: seq char
  timestamp: DateTime
where
  channel ‚àà {"messageAdded", "chatAdded", "chatRemoved"} ‚àß
  #payload > 0


/*
 * Operation: Publish Event to PostgreSQL
 * 
 * Publishes an event using PostgreSQL NOTIFY.
 * This ensures events are distributed across all server instances.
 * 
 * Corresponds to: PubSub.publish(triggerName, payload)
 */
schema PublishToPostgres
  ŒîApplicationState
  PubSubState
  ConnectionPoolState
  eventType?: EventType
  payload?: MessageID ‚à™ ChatID
  success!: ùîπ
where
  /* Map event type to PostgreSQL channel */
  let channel == 
    (eventType? = messageAdded ‚áí "messageAdded")
    ‚äï (eventType? = chatAdded ‚áí "chatAdded")
    ‚äï (eventType? = chatRemoved ‚áí "chatRemoved") ‚Ä¢
    /* Serialize payload */
    let serializedPayload == /* JSON.stringify(payload?) */ ‚Ä¢
      /* Execute PostgreSQL NOTIFY */
      /* SQL: NOTIFY channel, serializedPayload */
      success! = true ‚àß
      /* Event added to queue for processing */
      pubsubState'.eventQueue = pubsubState.eventQueue ‚å¢ 
        ‚ü®PubSubEvent' | 
          eventType = eventType? ‚àß 
          payload = payload? ‚àß 
          timestamp = /* current time */‚ü©


/*
 * Operation: Listen for PostgreSQL Notifications
 * 
 * Registers a listener for PostgreSQL NOTIFY events.
 * Called during subscription setup.
 * 
 * Corresponds to: PostgresPubSub.asyncIterator(triggers)
 */
schema ListenPostgresNotifications
  ŒîApplicationState
  PubSubState
  ConnectionPoolState
  channels?: seq (seq char)
  success!: ùîπ
where
  /* For each channel, execute LISTEN */
  ‚àÄ channel: seq char ‚Ä¢ channel ‚àà ran channels? ‚áí
    (/* SQL: LISTEN channel */
     pubsubState'.postgresChannel = 
       pubsubState.postgresChannel ‚äï 
       {channel ‚Ü¶ /* map to EventType */} ‚àß
     success! = true
    )


/*
 * Operation: Receive PostgreSQL Notification
 * 
 * Receives and processes a PostgreSQL NOTIFY event.
 * Distributes the event to relevant subscribers.
 */
schema ReceivePostgresNotification
  ŒîApplicationState
  PubSubState
  ActiveSessions
  notification?: PostgresNotifyPayload
  notifiedSubscriptions!: seq (seq char)
where
  /* Parse notification payload */
  let event == /* deserialize notification */ ‚Ä¢
    /* Find all subscriptions for this event type */
    let relevantSubs == 
      {sid ‚Ü¶ sub | sid: seq char; sub: ActiveSubscription ‚Ä¢
        sid ‚àà dom pubsubState.subscriptions ‚àß
        sub = pubsubState.subscriptions(sid) ‚àß
        sub.eventType = event.eventType} ‚Ä¢
      /* Filter subscriptions based on filter function */
      notifiedSubscriptions! = 
        ‚ü®sid | sid: seq char; sub: ActiveSubscription ‚Ä¢
          sid ‚àà dom relevantSubs ‚àß
          sub = relevantSubs(sid) ‚àß
          let session == activeSessions.sessions(sub.sessionId) ‚Ä¢
            sub.filter(event, session)‚ü©


/*******************************************************************************
 * SECTION 3: GRAPHQL SUBSCRIPTION EVENT HANDLING
 ******************************************************************************/

/*
 * WebSocket Connection
 * 
 * Represents a WebSocket connection for GraphQL subscriptions.
 */
schema WebSocketConnection
  connectionId: seq char
  sessionId: seq char
  protocol: seq char
  state: seq char
  lastPing: DateTime
where
  #connectionId > 0 ‚àß
  protocol ‚àà {"graphql-ws", "graphql-transport-ws"} ‚àß
  state ‚àà {"connecting", "connected", "closing", "closed"}


/*
 * Active WebSocket Connections
 * 
 * Collection of all active WebSocket connections.
 */
schema WebSocketConnections
  connections: seq char ‚á∏ WebSocketConnection
where
  ‚àÄ cid: seq char ‚Ä¢ cid ‚àà dom connections ‚áí
    connections(cid).connectionId = cid


/*
 * WebSocket Message Types
 */
WSMessageType ::= connection_init 
                | connection_ack 
                | subscribe 
                | next 
                | complete 
                | ping 
                | pong


/*
 * WebSocket Message
 * 
 * Represents a message sent over WebSocket connection.
 */
schema WebSocketMessage
  id: seq char ‚à™ {null}
  type: WSMessageType
  payload: seq char ‚à™ {null}
where
  /* Subscribe messages must have an id */
  type = subscribe ‚áí id ‚â† null ‚àß payload ‚â† null


/*
 * Operation: Handle WebSocket Connection
 * 
 * Handles a new WebSocket connection for subscriptions.
 * 
 * Corresponds to: Apollo Server subscription setup
 */
schema HandleWebSocketConnection
  ŒîApplicationState
  ŒîWebSocketConnections
  request?: HTTPRequest
  connectionId!: seq char
  success!: ùîπ
where
  /* Generate unique connection ID */
  connectionId! ‚àâ dom connections ‚àß
  /* Create new WebSocket connection */
  let newConnection == WebSocketConnection' |
    newConnection.connectionId = connectionId! ‚àß
    newConnection.sessionId = /* extract from request */ ‚àß
    newConnection.protocol = "graphql-ws" ‚àß
    newConnection.state = "connecting" ‚àß
    newConnection.lastPing = /* current time */ ‚Ä¢
    connections' = connections ‚äï {connectionId! ‚Ü¶ newConnection} ‚àß
    success! = true


/*
 * Operation: Handle Subscription Message
 * 
 * Processes a subscription request from WebSocket client.
 * 
 * Corresponds to: GraphQL subscription resolver execution
 */
schema HandleSubscriptionMessage
  ŒîApplicationState
  ŒîPubSubState
  connectionId?: seq char
  message?: WebSocketMessage
  subscriptionId!: seq char
  success!: ùîπ
where
  message?.type = subscribe ‚áí
    (/* Parse subscription query from payload */
     let query == /* GraphQL.parse(message?.payload) */ ‚Ä¢
       /* Extract subscription name (messageAdded, chatAdded, etc.) */
       let subscriptionName == /* extract from query */ ‚Ä¢
         /* Create subscription using appropriate schema */
         /* (SubscribeMessageAdded, SubscribeChatAdded, etc.) */
         subscriptionId! ‚àâ dom pubsubState.subscriptions ‚àß
         success! = true
    )


/*
 * Operation: Send Subscription Data
 * 
 * Sends subscription data to WebSocket client when event occurs.
 * 
 * Corresponds to: WebSocket send() when event is published
 */
schema SendSubscriptionData
  ŒûApplicationState
  ŒûWebSocketConnections
  subscriptionId?: seq char
  event?: PubSubEvent
  data?: Message ‚à™ Chat ‚à™ ChatID
where
  subscriptionId? ‚àà dom pubsubState.subscriptions ‚áí
    let subscription == pubsubState.subscriptions(subscriptionId?) ‚Ä¢
      let session == activeSessions.sessions(subscription.sessionId) ‚Ä¢
        /* Apply subscription filter */
        subscription.filter(event?, session) ‚áí
          /* Resolve GraphQL fields for data */
          let resolvedData == /* resolve GraphQL fields */ ‚Ä¢
            /* Send message over WebSocket */
            let wsMessage == WebSocketMessage' |
              wsMessage.id = subscription.subscriptionId ‚àß
              wsMessage.type = next ‚àß
              wsMessage.payload = /* JSON.stringify(resolvedData) */ ‚Ä¢
              /* WebSocket.send(wsMessage) */
              true


/*******************************************************************************
 * SECTION 4: REST DATA SOURCE PATTERN
 ******************************************************************************/

/*
 * REST Data Source Configuration
 * 
 * Base configuration for Apollo REST Data Source.
 */
schema RESTDataSourceConfig
  baseURL: URL
  requestTimeout: ‚Ñï
  cacheTTL: ‚Ñï
  headers: seq char ‚á∏ seq char
where
  #baseURL > 0 ‚àß
  requestTimeout > 0 ‚àß
  cacheTTL > 0


/*
 * HTTP Request with Data Source
 * 
 * Generic HTTP request using REST Data Source.
 */
schema RESTDataSourceRequest[Params, Response]
  ŒûRESTDataSourceConfig
  ŒûRESTDataSourceCache
  method: seq char
  path: seq char
  params: Params
  response!: Response
  cacheHit!: ùîπ
where
  method ‚àà {"GET", "POST", "PUT", "DELETE", "PATCH"}


/*
 * Operation: Generic GET Request with Caching
 * 
 * Performs a GET request with automatic caching.
 * Implements the RESTDataSource caching strategy.
 */
schema CachedGETRequest[Response]
  RESTDataSourceConfig
  ŒîRESTDataSourceCache
  path?: seq char
  queryParams?: seq char ‚á∏ seq char
  response!: Response
  fromCache!: ùîπ
where
  /* Build full URL with query params */
  let fullURL == baseURL ‚å¢ path? ‚å¢ 
                 /* serialize queryParams */ ‚Ä¢
    /* Check cache */
    (fullURL ‚àà dom urlCache ‚áí
      let (cachedResponse, timestamp) == urlCache(fullURL) ‚Ä¢
        (/* Check if cache is valid */
         /* current_time - timestamp < cacheTTL */ ‚áí
           (response! = /* deserialize(cachedResponse) */ ‚àß
            fromCache! = true)
         ‚äï
           /* Cache expired - fetch fresh */
           let freshResponse == /* HTTP GET fullURL */ ‚Ä¢
             urlCache' = urlCache ‚äï 
               {fullURL ‚Ü¶ (/* serialize(freshResponse) */, /* current_time */)} ‚àß
             response! = freshResponse ‚àß
             fromCache! = false
        )
    )
    ‚äï
      /* Not in cache - fetch and cache */
      let freshResponse == /* HTTP GET fullURL */ ‚Ä¢
        urlCache' = urlCache ‚äï 
          {fullURL ‚Ü¶ (/* serialize(freshResponse) */, /* current_time */)} ‚àß
        response! = freshResponse ‚àß
        fromCache! = false


/*******************************************************************************
 * SECTION 5: ERROR HANDLING FOR EXTERNAL INTEGRATIONS
 ******************************************************************************/

/*
 * External Service Error
 * 
 * Represents an error from an external service.
 */
schema ExternalServiceError
  serviceName: seq char
  errorType: seq char
  statusCode: ‚Ñï ‚à™ {null}
  errorMessage: seq char
  timestamp: DateTime
  retryable: ùîπ
where
  serviceName ‚àà {"unsplash", "postgres-pubsub"} ‚àß
  errorType ‚àà {"network_error", "timeout", "rate_limit", 
                "auth_error", "server_error", "client_error"}


/*
 * Operation: Handle External Service Error
 * 
 * Generic error handling for external service failures.
 * Implements retry logic and fallback strategies.
 */
schema HandleExternalServiceError
  ŒûApplicationState
  error?: ExternalServiceError
  fallbackData!: seq char ‚à™ {null}
  shouldRetry!: ùîπ
  retryAfter!: ‚Ñï
where
  /* Determine if error is retryable */
  shouldRetry! = error?.retryable ‚àß
    error?.errorType ‚àà {"network_error", "timeout", "rate_limit"}
  ‚àß
  /* Set retry delay based on error type */
  (error?.errorType = "rate_limit" ‚áí
    retryAfter! = 3600000  // 1 hour for rate limits
  )
  ‚äï (error?.errorType = "timeout" ‚áí
    retryAfter! = 5000  // 5 seconds for timeouts
  )
  ‚äï (error?.errorType = "network_error" ‚áí
    retryAfter! = 10000  // 10 seconds for network errors
  )
  ‚àß
  /* Provide fallback data if available */
  (error?.serviceName = "unsplash" ‚áí
    fallbackData! = "https://randomuser.me/api/portraits/thumb/lego/1.jpg"
  )
  ‚äï
    fallbackData! = null


/*******************************************************************************
 * SECTION 6: INTEGRATION HEALTH MONITORING
 ******************************************************************************/

/*
 * External Service Health Status
 * 
 * Tracks the health of external service integrations.
 */
schema ServiceHealthStatus
  serviceName: seq char
  status: seq char
  lastSuccessfulRequest: DateTime
  lastFailedRequest: DateTime
  consecutiveFailures: ‚Ñï
  averageLatency: ‚Ñï
where
  serviceName ‚àà {"unsplash", "postgres-pubsub"} ‚àß
  status ‚àà {"healthy", "degraded", "unavailable"}


/*
 * Operation: Check Service Health
 * 
 * Performs a health check on an external service.
 */
schema CheckServiceHealth
  ŒûApplicationState
  serviceName?: seq char
  health!: ServiceHealthStatus
where
  serviceName? ‚àà {"unsplash", "postgres-pubsub"} ‚áí
    /* Perform lightweight health check request */
    let healthCheck == /* service-specific health check */ ‚Ä¢
      health!.serviceName = serviceName? ‚àß
      /* Determine status based on recent history */
      (health!.consecutiveFailures < 3 ‚áí
        health!.status = "healthy"
      )
      ‚äï (health!.consecutiveFailures < 10 ‚áí
        health!.status = "degraded"
      )
      ‚äï
        health!.status = "unavailable"


/*******************************************************************************
 * SECTION 7: DATA TRANSFORMATION CONTRACTS
 ******************************************************************************/

/*
 * Data Transformation: External to Internal
 * 
 * Transforms external API responses to internal data models.
 */
schema TransformExternalToInternal[External, Internal]
  external?: External
  internal!: Internal
where
  /* Transformation logic depends on types */
  /* For Unsplash: extract photo URL from complex response */
  /* For PubSub: deserialize event payload */
  true


/*
 * Unsplash Photo to URL Transformation
 * 
 * Extracts the appropriate photo URL from Unsplash response.
 */
schema TransformUnsplashPhotoToURL
  TransformExternalToInternal[UnsplashPhoto, URL]
where
  external? ‚â† null ‚áí
    internal! = external?.urls("regular")


/*
 * PostgreSQL Notification to Event Transformation
 * 
 * Transforms PostgreSQL NOTIFY payload to PubSubEvent.
 */
schema TransformPostgresNotificationToEvent
  TransformExternalToInternal[PostgresNotifyPayload, PubSubEvent]
where
  external? ‚â† null ‚áí
    let eventType == 
      (external?.channel = "messageAdded" ‚áí messageAdded)
      ‚äï (external?.channel = "chatAdded" ‚áí chatAdded)
      ‚äï (external?.channel = "chatRemoved" ‚áí chatRemoved) ‚Ä¢
      internal!.eventType = eventType ‚àß
      internal!.payload = /* deserialize external?.payload */ ‚àß
      internal!.timestamp = external?.timestamp


/*******************************************************************************
 * END OF INTEGRATIONS SPECIFICATION
 ******************************************************************************/

/*
 * NOTES ON IMPLEMENTATION:
 * 
 * 1. Unsplash API Integration:
 *    - Uses Apollo RESTDataSource for HTTP caching
 *    - Rate limited to 50 requests/hour (demo tier)
 *    - Fallback to default images on failure
 *    - Cache TTL configured per request type
 * 
 * 2. PostgreSQL PubSub:
 *    - Uses graphql-postgres-subscriptions package
 *    - LISTEN/NOTIFY provides scalable real-time events
 *    - Events distributed across all server instances
 *    - Subscription filters applied per client
 * 
 * 3. GraphQL Subscriptions:
 *    - WebSocket protocol: graphql-ws
 *    - Connection lifecycle: init, ack, subscribe, next, complete
 *    - Apollo Server manages WebSocket connections
 *    - Subscriptions tied to authenticated sessions
 * 
 * 4. REST Data Source:
 *    - Automatic request/response caching
 *    - Configurable TTL per endpoint
 *    - Retry logic for transient failures
 *    - Circuit breaker pattern for failing services
 * 
 * 5. Error Handling:
 *    - Graceful degradation on external service failures
 *    - Fallback data provided when available
 *    - Exponential backoff for retries
 *    - Health monitoring for service status
 * 
 * 6. Data Transformation:
 *    - External API responses mapped to internal types
 *    - Type safety maintained throughout
 *    - Validation at integration boundaries
 *    - Schema evolution handled with versioning
 */
